#* @vtlvariable name="ctx" type="org.kevoree.modeling.kotlin.generator.GenerationContext" *#
#* @vtlvariable name="helper" type="org.kevoree.modeling.kotlin.generator.ProcessorHelperClass" *#

#set($packName = ${helper.fqn($ctx, $ctx.getBasePackageForUtilitiesGeneration())})

package ${packName}.trace

import ${packName}.util.ActionType

/**
 * Created by duke on 25/07/13.
 */

#if(${ctx.jS})
trait ModelTrace {
    fun toString() : String
}
#else
trait ModelTrace: java.io.Serializable { }
#end

class ModelAddTrace(val srcPath: String, val refName: String, val previousPath : String?, val typeName: String?): ModelTrace {
    override fun toString() : String {
#if($ctx.jS)
val buffer = java.lang.StringBuilder("")
#else
val buffer = java.lang.StringBuilder()
#end
        buffer.append("{ \"traceType\" : "+ActionType.ADD+" , \"src\" : \"" + srcPath + "\", \"refname\" : \""+refName+"\"")
        if(previousPath != null){ buffer.append(", \"previouspath\" : \""+previousPath+"\"") }
        if(typeName != null){ buffer.append(", \"typename\" : \""+typeName+"\"") }
        buffer.append("}")
        return buffer.toString()
    }
}

class ModelAddAllTrace(val srcPath: String, val refName: String, val previousPath : List<String>?, val typeName: List<String>?): ModelTrace {

    private fun mkString(ss : List<String>?) : String? {
            if(ss == null){return null}
        #if($ctx.jS)
            val buffer = java.lang.StringBuilder("")
        #else
            val buffer = java.lang.StringBuilder()
        #end
            var isFirst = true
            for(s in ss){
                if(!isFirst){
                    buffer.append(",")
                }
                buffer.append(s)
                isFirst = false
            }
            return buffer.toString()
    }

    override fun toString() : String {
        #if($ctx.jS)
            val buffer = java.lang.StringBuilder("")
        #else
            val buffer = java.lang.StringBuilder()
        #end
        buffer.append("{ \"traceType\" : "+ActionType.ADD_ALL+" , \"src\" : \"" + srcPath + "\", \"refname\" : \""+refName+"\"")
        if(previousPath!= null){ buffer.append(", \"previouspath\" : \""+mkString(previousPath)+"\"") }
        if(typeName!= null){ buffer.append(", \"typename\" : \""+mkString(typeName)+"\"") }
        buffer.append("}")
        return buffer.toString()
    }
}

class ModelRemoveTrace(val srcPath: String, val refName: String, val objPath : String): ModelTrace {
    override fun toString() : String {
        return "{ \"traceType\" : "+ActionType.REMOVE+" , \"src\" : \"" + srcPath + "\", \"refname\" : \""+refName+"\", \"objpath\" : \""+objPath+"\" }"
    }
}

class ModelRemoveAllTrace(val srcPath: String, val refName: String): ModelTrace {
    override fun toString() : String {
        return "{ \"traceType\" : "+ActionType.REMOVE_ALL+" , \"src\" : \"" + srcPath + "\", \"refname\" : \""+refName+"\" }"
    }
}

class ModelSetTrace(val srcPath: String, val refName: String, val objPath : String?, val content : String?, val typeName: String?): ModelTrace {
    override fun toString() : String {
        #if($ctx.jS)
            val buffer = java.lang.StringBuilder("")
        #else
            val buffer = java.lang.StringBuilder()
        #end
        buffer.append("{ \"traceType\" : "+ActionType.SET+" , \"src\" : \"" + srcPath + "\", \"refname\" : \""+refName+"\"")
        if(objPath!=null){ buffer.append(", \"objpath\" : \""+objPath+"\"") }
        if(content!=null){ buffer.append(", \"content\" : \""+content+"\"") }
        if(typeName!=null){ buffer.append(", \"typename\" : \""+typeName+"\"") }
        buffer.append("}")
        return buffer.toString()
    }
}

class TraceSequence(){

    var traces = java.util.ArrayList<ModelTrace>()

    fun getTraces() : List<ModelTrace> {
            return traces;
    }

    fun populate(addtraces : List<ModelTrace>) : TraceSequence {
        traces.addAll(addtraces);
        return this;
    }

    fun populateFromString(addtracesTxt : String) : TraceSequence {
#if($ctx.jS)
        val bytes = ByteArray(addtracesTxt.length)
        var i = 0
        while(i < addtracesTxt.length){
            bytes.set(i,addtracesTxt.get(i) as Byte)
            i = i +1
        }
        return populateFromStream(java.io.ByteArrayInputStream(bytes))
#else
        return populateFromStream(java.io.ByteArrayInputStream(addtracesTxt.toByteArray()))
#end
    }

    fun populateFromStream(inputStream : java.io.InputStream) : TraceSequence {
                val parser = ${packName}.loader.JsonReader(inputStream);
                parser.beginArray();
                val keys = java.util.HashMap<String,String>();
                while (parser.hasNext() && (parser.peek() != parser.PEEKED_END_ARRAY)) {
                        parser.beginObject();
                        keys.clear();
                        parser.nextName();
                        val value = parser.nextInt();
                        while (parser.hasNext() && (parser.peek() != parser.PEEKED_END_OBJECT)) {
                            keys.put(parser.nextName(),parser.nextString());
                        }
                        parser.endObject();
                        when(value) {
                            ActionType.SET -> {
                                traces.add(ModelSetTrace(keys.get("src")!!,keys.get("refname")!!,keys.get("objpath"),keys.get("content"),keys.get("typename")));
                            }
                            ActionType.ADD -> {
                                traces.add(ModelAddTrace(keys.get("src")!!,keys.get("refname")!!,keys.get("previouspath")!!,keys.get("typename")));
                            }
                            ActionType.ADD_ALL -> {
                                traces.add(ModelAddAllTrace(keys.get("src")!!,keys.get("refname")!!,keys.get("content")?.split(";")?.toList(),keys.get("typename")?.split(";")?.toList()));
                            }
                            ActionType.REMOVE -> {
                                traces.add(ModelRemoveTrace(keys.get("src")!!,keys.get("refname")!!,keys.get("objpath")!!));
                            }
                            ActionType.REMOVE_ALL -> {
                                traces.add(ModelRemoveAllTrace(keys.get("src")!!,keys.get("refname")!!));
                            }
                            ActionType.RENEW_INDEX-> {
                            }
                            else -> {}
                        }
                }
                return this;
    }

    fun exportToString() : String {
#if($ctx.jS)
        val buffer = java.lang.StringBuilder("")
#else
        val buffer = java.lang.StringBuilder()
#end
         buffer.append("[")
         var isFirst = true
         for(trace in traces){
              if(!isFirst){
                buffer.append(",")
              }
              buffer.append(trace.toString())
              isFirst = false
         }
         buffer.append("]")
         return buffer.toString()
    }

}